<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Christmas Tree</title>
  <style>
    html, body { margin:0; height:100%; background:#07121f; overflow:hidden; }
    canvas { display:block; width:100vw; height:100vh; touch-action: manipulation; }
    .hint{
      position:fixed; left:12px; right:12px; bottom:12px;
      font: 14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: rgba(255,255,255,.75); text-align:center; user-select:none;
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div class="hint">打开即运行｜点击屏幕：切换风格/重置彩灯</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  // 主题（点屏幕切换）
  const themes = [
    { bg:'#07121f', tree:'#1db954', treeDark:'#148a3f', trunk:'#8b5a2b', text:'#b8fff1' },
    { bg:'#0b0b12', tree:'#2ecc71', treeDark:'#1f9e55', trunk:'#7a4a21', text:'#ffe9a8' },
    { bg:'#071a10', tree:'#22c55e', treeDark:'#178a42', trunk:'#7c3f1d', text:'#c7d2fe' },
  ];
  let themeIndex = 0;

  // 彩灯颜色
  const bulbColors = ['#ff4d4d', '#ffd166', '#4dabff', '#d66bff', '#ffffff'];

  // 状态
  let W = 0, H = 0, DPR = 1;
  let bulbs = [];     // 彩灯位置
  let snow = [];      // 雪花
  let t = 0;

  function resize() {
    DPR = Math.min(2, window.devicePixelRatio || 1);
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);
    canvas.width = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    resetScene();
  }

  function rand(a, b){ return a + Math.random() * (b - a); }

  function resetScene() {
    const th = themes[themeIndex];
    document.body.style.background = th.bg;

    bulbs = [];
    snow = [];

    // 根据屏幕自适配树大小
    const cx = W * 0.5;
    const topY = H * 0.12;
    const treeH = H * 0.62;
    const baseY = topY + treeH;
    const baseW = Math.min(W * 0.78, treeH * 0.95);

    // 在树的三角区域内随机生成彩灯点
    const bulbCount = Math.floor(Math.min(140, Math.max(50, (W*H) / 18000)));
    for (let i=0; i<bulbCount; i++){
      const y = rand(topY + 10, baseY - 20);
      const k = (y - topY) / treeH;          // 0..1
      const half = (baseW * (0.12 + 0.88*k)) / 2; // 越往下越宽
      const x = cx + rand(-half, half);
      bulbs.push({
        x, y,
        r: rand(2.2, 4.2),
        c: bulbColors[(Math.random()*bulbColors.length)|0],
        phase: rand(0, Math.PI*2),
        speed: rand(0.8, 1.8),
      });
    }

    // 雪花
    const snowCount = Math.floor(Math.min(220, Math.max(80, (W*H) / 9000)));
    for (let i=0; i<snowCount; i++){
      snow.push({
        x: rand(0, W), y: rand(0, H),
        r: rand(0.8, 2.2),
        vx: rand(-0.25, 0.25),
        vy: rand(0.35, 1.2),
        a: rand(0.25, 0.9),
      });
    }

    // 存一些几何参数供绘制用
    canvas._geo = { cx, topY, treeH, baseY, baseW };
  }

  function drawStar(cx, y, size) {
    ctx.save();
    ctx.translate(cx, y);
    ctx.rotate(-Math.PI/10);
    ctx.beginPath();
    for (let i=0;i<10;i++){
      const r = (i%2===0) ? size : size*0.45;
      const a = i * Math.PI/5;
      ctx.lineTo(Math.cos(a)*r, Math.sin(a)*r);
    }
    ctx.closePath();
    ctx.fillStyle = '#ffd166';
    ctx.shadowColor = 'rgba(255, 209, 102, .9)';
    ctx.shadowBlur = 16;
    ctx.fill();
    ctx.restore();
  }

  function draw() {
    const th = themes[themeIndex];
    const { cx, topY, treeH, baseY, baseW } = canvas._geo;

    // 背景渐变
    const g = ctx.createLinearGradient(0, 0, 0, H);
    g.addColorStop(0, th.bg);
    g.addColorStop(1, '#000000');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, W, H);

    // 雪
    for (const s of snow) {
      s.x += s.vx;
      s.y += s.vy;
      if (s.y > H + 10) { s.y = -10; s.x = rand(0, W); }
      if (s.x < -10) s.x = W + 10;
      if (s.x > W + 10) s.x = -10;
      ctx.globalAlpha = s.a;
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // 树（用多层三角形制造层次）
    const layers = 6;
    for (let i=0;i<layers;i++){
      const k0 = i / layers;
      const k1 = (i+1) / layers;
      const y0 = topY + treeH * k0;
      const y1 = topY + treeH * k1;
      const w0 = baseW * (0.18 + 0.82*k0);
      const w1 = baseW * (0.18 + 0.82*k1);

      ctx.beginPath();
      ctx.moveTo(cx, y0);
      ctx.lineTo(cx - w1/2, y1);
      ctx.lineTo(cx + w1/2, y1);
      ctx.closePath();

      ctx.fillStyle = (i % 2 === 0) ? th.tree : th.treeDark;
      ctx.shadowColor = 'rgba(0,0,0,.25)';
      ctx.shadowBlur = 10;
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    // 树干
    const trunkW = Math.max(26, baseW * 0.14);
    const trunkH = Math.max(42, treeH * 0.14);
    ctx.fillStyle = th.trunk;
    ctx.roundRect(cx - trunkW/2, baseY - trunkH*0.15, trunkW, trunkH, 10);
    ctx.fill();

    // 顶部星星
    drawStar(cx, topY - 12, Math.min(22, W*0.045));

    // 彩灯（闪烁）
    for (const b of bulbs) {
      const blink = 0.35 + 0.65 * (0.5 + 0.5*Math.sin(t*b.speed + b.phase));
      ctx.globalAlpha = 0.25 + 0.75*blink;

      // 光晕
      ctx.fillStyle = b.c;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r*2.3, 0, Math.PI*2);
      ctx.fill();

      // 灯体
      ctx.globalAlpha = 0.75 + 0.25*blink;
      ctx.fillStyle = '#0b0b12';
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r*1.12, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = b.c;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // 文字
    ctx.fillStyle = th.text;
    ctx.font = 600 ${Math.max(18, Math.min(32, W*0.06))}px system-ui, -apple-system, Segoe UI, Roboto, Arial;
    ctx.textAlign = 'center';
    ctx.shadowColor = 'rgba(0,0,0,.35)';
    ctx.shadowBlur = 8;
    ctx.fillText('Merry Christmas!', cx, Math.min(H - 24, baseY + trunkH + 40));
    ctx.shadowBlur = 0;
  }

  function loop() {
    t += 0.06;
    draw();
    requestAnimationFrame(loop);
  }

  // 点击/触摸切换主题并重置彩灯布局
  window.addEventListener('pointerdown', () => {
    themeIndex = (themeIndex + 1) % themes.length;
    resetScene();
  });

  window.addEventListener('resize', resize);

  // 兼容旧浏览器：补一个 roundRect（多数现代浏览器已有）
  if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      r = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+r, y);
      this.arcTo(x+w, y, x+w, y+h, r);
      this.arcTo(x+w, y+h, x, y+h, r);
      this.arcTo(x, y+h, x, y, r);
      this.arcTo(x, y, x+w, y, r);
      this.closePath();
      return this;
    }
  }

  resize();
  loop();
})();
</script>
</body>
</html>
